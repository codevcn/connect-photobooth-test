import { resizeCanvas } from '@/utils/helpers'
import { domToBlob, domToCanvas } from 'modern-screenshot'

/**
 * Detect iOS device (iPhone, iPad, iPod)
 */
const isIOSDevice = (): boolean => {
  const userAgent = navigator.userAgent || navigator.vendor || (window as any).opera
  // Check for iOS devices
  if (/iPad|iPhone|iPod/.test(userAgent) && !(window as any).MSStream) {
    return true
  }
  // Check for iPad on iOS 13+ (reports as Mac)
  if (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1) {
    return true
  }
  return false
}

/**
 * Get iOS canvas memory limit
 * iOS c√≥ gi·ªõi h·∫°n canvas size r·∫•t nghi√™m ng·∫∑t:
 * - iPhone 6/7/8: ~16MP (4096x4096)
 * - iPhone X+: ~32MP nh∆∞ng v·ªõi nhi·ªÅu ·∫£nh s·∫Ω b·ªã gi·∫£m
 * - Khi c√≥ nhi·ªÅu ·∫£nh l·ªõn, memory limit s·∫Ω b·ªã exceeded
 */
const getIOSCanvasLimit = (imageCount: number): number => {
  // Gi·∫£m d·∫ßn theo s·ªë l∆∞·ª£ng ·∫£nh
  if (imageCount >= 6) return 2048  // Max 2048px cho 6+ ·∫£nh
  if (imageCount >= 4) return 3072  // Max 3072px cho 4+ ·∫£nh
  if (imageCount >= 2) return 4096  // Max 4096px cho 2+ ·∫£nh
  return 4096
}

/**
 * Wait for all images in container to load
 */
const waitForImagesToLoad = (container: HTMLElement): Promise<void> => {
  return new Promise((resolve, reject) => {
    const images = Array.from(container.querySelectorAll('img'))
    
    if (images.length === 0) {
      resolve()
      return
    }

    let loadedCount = 0
    let hasError = false
    const timeout = setTimeout(() => {
      if (!hasError) {
        console.warn('‚ö†Ô∏è Image loading timeout, proceeding anyway...')
        resolve()
      }
    }, 10000) // 10s timeout

    const checkComplete = () => {
      loadedCount++
      if (loadedCount === images.length) {
        clearTimeout(timeout)
        if (!hasError) {
          resolve()
        }
      }
    }

    images.forEach((img) => {
      if (img.complete && img.naturalHeight !== 0) {
        checkComplete()
      } else {
        img.addEventListener('load', checkComplete, { once: true })
        img.addEventListener('error', (e) => {
          console.error('‚ùå Image failed to load:', img.src, e)
          hasError = true
          clearTimeout(timeout)
          reject(new Error(`Failed to load image: ${img.src}`))
        }, { once: true })
      }
    })
  })
}

/**
 * Calculate optimal scale based on image count, container size, and device type
 */
const calculateOptimalScale = (container: HTMLElement, defaultScale: number = 8): number => {
  const images = container.querySelectorAll('img')
  const imageCount = images.length
  const containerWidth = container.getBoundingClientRect().width
  const containerHeight = container.getBoundingClientRect().height
  const isIOS = isIOSDevice()

  console.log('üì± Device detection:', { isIOS, imageCount, containerWidth, containerHeight, defaultScale })

  // iOS c·∫ßn x·ª≠ l√Ω ƒë·∫∑c bi·ªát v√¨ c√≥ memory limit nghi√™m ng·∫∑t
  if (isIOS) {
    const maxCanvasSize = getIOSCanvasLimit(imageCount)
    const maxDimension = Math.max(containerWidth, containerHeight)
    
    // T√≠nh scale t·ªëi ƒëa ƒë·ªÉ kh√¥ng v∆∞·ª£t qu√° gi·ªõi h·∫°n iOS
    let iosMaxScale = Math.floor(maxCanvasSize / maxDimension)
    
    // Gi·∫£m th√™m cho tr∆∞·ªùng h·ª£p nhi·ªÅu ·∫£nh ƒë·ªÉ tr√°nh memory overflow
    if (imageCount >= 6) {
      iosMaxScale = Math.min(iosMaxScale, 2) // Max scale = 2 cho 6+ ·∫£nh tr√™n iOS
      console.log('üçé iOS 6+ images: forcing scale to', iosMaxScale)
    } else if (imageCount >= 4) {
      iosMaxScale = Math.min(iosMaxScale, 3) // Max scale = 3 cho 4+ ·∫£nh tr√™n iOS
      console.log('üçé iOS 4+ images: limiting scale to', iosMaxScale)
    }

    const finalScale = Math.max(1, Math.min(defaultScale, iosMaxScale))
    console.log('üçé iOS final scale:', finalScale, '(requested:', defaultScale, ')')
    return finalScale
  }

  // Android v√† c√°c platform kh√°c - gi·ªØ nguy√™n logic c≈©
  if (imageCount >= 6) {
    console.log('üîß 6+ images detected, reducing scale from', defaultScale, 'to', Math.max(4, defaultScale / 2))
    return Math.max(4, defaultScale / 2) // Min scale = 4
  } else if (imageCount >= 4) {
    console.log('üîß 4+ images detected, reducing scale from', defaultScale, 'to', Math.max(5, defaultScale * 0.7))
    return Math.max(5, defaultScale * 0.7)
  }

  // Check canvas size limit (most browsers: ~16,384px)
  const estimatedCanvasSize = Math.max(containerWidth, containerHeight) * defaultScale
  if (estimatedCanvasSize > 15000) {
    const adjustedScale = Math.floor(15000 / Math.max(containerWidth, containerHeight))
    console.log('üîß Canvas too large, adjusting scale to', adjustedScale)
    return Math.max(4, adjustedScale)
  }

  return defaultScale
}

/**
 * Crop canvas to a specific region
 */
const cropCanvas = (
  sourceCanvas: HTMLCanvasElement,
  x: number,
  y: number,
  cropWidth: number,
  cropHeight: number,
  outputWidth: number,
  outputHeight: number
): HTMLCanvasElement => {
  const croppedCanvas = document.createElement('canvas')
  croppedCanvas.width = cropWidth
  croppedCanvas.height = cropHeight

  const ctx = croppedCanvas.getContext('2d')
  if (!ctx) {
    throw new Error('Failed to get canvas context for cropping')
  }

  // Draw the cropped region
  ctx.drawImage(sourceCanvas, x, y, cropWidth, cropHeight, 0, 0, outputWidth, outputHeight)

  return croppedCanvas
}

type TUseHtlmToCanvasReturn = {
  saveHtmlAsImage: (
    htmContainer: HTMLDivElement,
    desiredImgMimeType: string | null,
    scale: number | undefined,
    onSaved: (imgData: Blob, canvas: HTMLCanvasElement) => void,
    onError: (error: Error) => void
  ) => void
  saveHtmlAsImageWithDesiredSizeOldVersion: (
    htmlContainer: HTMLDivElement,
    desiredOutputWidth: number,
    desiredOutputHeight: number,
    desiredImgMimeType: string | null,
    onSaved: (imgData: Blob, canvas: HTMLCanvasElement, originalCanvas: HTMLCanvasElement) => void,
    onError: (error: Error) => void
  ) => void
  saveHtmlAsImageCropped: (
    htmlContainer: HTMLDivElement,
    cropBounds: DOMRect,
    desiredOutputWidth: number,
    desiredOutputHeight: number,
    desiredImgMimeType: string | null,
    onSaved: (imgData: Blob, canvas: HTMLCanvasElement) => void,
    onError: (error: Error) => void
  ) => void
  saveHtmlAsImageWithDesiredSize: (
    htmlContainer: HTMLDivElement,
    transparentPrintAreaContainer: HTMLDivElement,
    desiredOutputWidth: number,
    desiredOutputHeight: number,
    upScale: number,
    desiredImgMimeType: string | null,
    onSaved: (
      fullContainerImageData: Blob,
      allowedPrintAreaImageData: Blob,
      allowedPrintAreaCanvas: HTMLCanvasElement
    ) => void,
    onError: (error: Error) => void
  ) => void
  savePrintAreaAsImage: (
    htmContainer: HTMLDivElement,
    allowedPrintArea: HTMLDivElement,
    desiredImgMimeType: string | null,
    upScale: number | undefined,
    onSaved: (
      fullPrintAreaContainer: Blob,
      allowedPrintAreaImage: Blob,
      allowedPrintAreaCanvas: HTMLCanvasElement
    ) => void,
    onError: (error: Error) => void
  ) => void
}

export const useHtmlToCanvas = (): TUseHtlmToCanvasReturn => {
  const savePrintAreaAsImage = async (
    htmContainer: HTMLDivElement,
    allowedPrintArea: HTMLDivElement,
    desiredImgMimeType: string | null,
    upScale: number | undefined,
    onSaved: (
      fullPrintAreaContainer: Blob,
      allowedPrintAreaImage: Blob,
      allowedPrintAreaCanvas: HTMLCanvasElement
    ) => void,
    onError: (error: Error) => void
  ) => {
    try {
      await document.fonts.ready
      const scale: number = upScale || 8
      const [fullContainerCanvas, allowedPrintAreaCanvas] = await Promise.all([
        domToCanvas(htmContainer, {
          scale: scale,
          quality: 1,
          type: desiredImgMimeType || 'image/webp',
        }),
        domToCanvas(allowedPrintArea, {
          scale: scale,
          quality: 1,
          type: desiredImgMimeType || 'image/webp',
        }),
      ])
      const outputList: Blob[] = []
      fullContainerCanvas.toBlob((blob) => {
        if (blob) {
          outputList.push(blob)
          if (outputList.length === 2) {
            onSaved(outputList[0], outputList[1], allowedPrintAreaCanvas)
          }
        } else {
          throw new Error('Failed to convert entire product canvas to Blob')
        }
      }, desiredImgMimeType || 'image/webp')
      allowedPrintAreaCanvas.toBlob((blob) => {
        if (blob) {
          outputList.push(blob)
          if (outputList.length === 2) {
            onSaved(outputList[0], outputList[1], allowedPrintAreaCanvas)
          }
        } else {
          throw new Error('Failed to convert allowed print area canvas to Blob')
        }
      }, desiredImgMimeType || 'image/webp')
    } catch (error) {
      onError(error as Error)
    }
  }

  const saveHtmlAsImage = async (
    htmContainer: HTMLDivElement,
    desiredImgMimeType: string | null,
    upScale: number | undefined,
    onSaved: (imgData: Blob, canvas: HTMLCanvasElement) => void,
    onError: (error: Error) => void
  ) => {
    requestIdleCallback(async () => {
      try {
        await document.fonts.ready
        const scale: number = upScale || 8
        const canvas = await domToCanvas(htmContainer, {
          scale: scale,
          quality: 1,
          type: desiredImgMimeType || 'image/webp',
        })
        canvas.toBlob((blob) => {
          if (blob) {
            onSaved(blob, canvas)
          } else {
            onError(new Error('Failed to convert resized canvas to Blob'))
          }
        })
      } catch (error) {
        onError(error as Error)
      }
    })
  }

  const saveHtmlAsImageWithDesiredSize = async (
    htmlContainer: HTMLDivElement,
    transparentPrintAreaContainer: HTMLDivElement,
    desiredOutputWidth: number,
    desiredOutputHeight: number,
    upScale: number = 8,
    desiredImgMimeType: string | null,
    onSaved: (
      fullContainerImageData: Blob,
      allowedPrintAreaImageData: Blob,
      allowedPrintAreaCanvas: HTMLCanvasElement
    ) => void,
    onError: (error: Error) => void
  ) => {
    requestIdleCallback(async () => {
      try {
        console.log('üé® Starting capture process...')
        
        // Calculate optimal scale based on content
        const optimalScale = calculateOptimalScale(transparentPrintAreaContainer, upScale)
        console.log('üìä Using scale:', optimalScale, '(original:', upScale, ')')

        // Wait for all images to load
        console.log('‚è≥ Waiting for images to load...')
        await Promise.race([
          waitForImagesToLoad(htmlContainer),
          waitForImagesToLoad(transparentPrintAreaContainer)
        ])
        console.log('‚úÖ All images loaded')

        // Wait for fonts
        await Promise.race([
          document.fonts.ready,
          new Promise(resolve => setTimeout(resolve, 3000)) // 3s timeout
        ])
        console.log('‚úÖ Fonts ready')

        // Small delay to ensure rendering is complete
        await new Promise(resolve => setTimeout(resolve, 100))

        console.log('üì∏ Capturing mockup image...')
        const mokupImageBlob = await domToBlob(htmlContainer, {
          scale: optimalScale,
          quality: 1,
          type: desiredImgMimeType || 'image/webp',
        })
        console.log('‚úÖ Mockup captured:', mokupImageBlob.size, 'bytes')

        // L·∫•y v·ªã tr√≠ c·ªßa container v√† element c·∫ßn crop
        const containerRect = transparentPrintAreaContainer.getBoundingClientRect()
        const elementRect = transparentPrintAreaContainer
          .querySelector('.NAME-print-area-allowed')
          ?.getBoundingClientRect()
        
        if (!elementRect) {
          throw new Error('Print area element not found')
        }

        // T√≠nh v·ªã tr√≠ relative c·ªßa element so v·ªõi container
        const relativeX = elementRect.left - containerRect.left
        const relativeY = elementRect.top - containerRect.top
        
        const imageDataPromises: Promise<Blob>[] = []

        console.log('üì∏ Capturing full canvas...')
        const fullCanvas = await domToCanvas(transparentPrintAreaContainer, {
          scale: optimalScale,
          quality: 1,
          type: desiredImgMimeType || 'image/webp',
        })
        console.log('‚úÖ Full canvas captured:', fullCanvas.width, 'x', fullCanvas.height)
        imageDataPromises.push(
          new Promise((resolve, reject) => {
            fullCanvas.toBlob((blob) => {
              if (blob) {
                resolve(blob)
              } else {
                reject(new Error('Failed to convert full canvas to Blob'))
              }
            }, desiredImgMimeType || 'image/webp')
          })
        )

        // T·∫°o canvas m·ªõi ƒë·ªÉ crop
        const croppedCanvas = document.createElement('canvas')
        const ctx = croppedCanvas.getContext('2d')

        if (!ctx) {
          return new Error('Failed to get canvas context for cropping')
        }

        // Set k√≠ch th∆∞·ªõc canvas crop (ƒë√£ scale) - s·ª≠ d·ª•ng optimalScale thay v√¨ upScale
        const cropWidth = elementRect.width * optimalScale
        const cropHeight = elementRect.height * optimalScale
        croppedCanvas.width = cropWidth
        croppedCanvas.height = cropHeight

        // Crop v√πng c·∫ßn thi·∫øt t·ª´ fullCanvas
        ctx.drawImage(
          fullCanvas,
          relativeX * optimalScale, // source x (ƒë√£ scale)
          relativeY * optimalScale, // source y (ƒë√£ scale)
          cropWidth, // source width
          cropHeight, // source height
          0, // destination x
          0, // destination y
          cropWidth, // destination width
          cropHeight // destination height
        )

        imageDataPromises.push(
          new Promise((resolve, reject) => {
            croppedCanvas.toBlob((blob) => {
              if (blob) {
                resolve(blob)
              } else {
                reject(new Error('Failed to convert cropped canvas to Blob'))
              }
            }, desiredImgMimeType || 'image/webp')
          })
        )
        const blobs = await Promise.all(imageDataPromises)
        
        // Ki·ªÉm tra n·∫øu blob qu√° nh·ªè (c√≥ th·ªÉ b·ªã tr·∫Øng/empty) - iOS issue
        const isIOS = isIOSDevice()
        if (isIOS && (mokupImageBlob.size < 1000 || blobs[1].size < 1000)) {
          console.error('‚ö†Ô∏è iOS: Blob size too small, might be empty/white image')
          console.log('üìä Blob sizes:', { mockup: mokupImageBlob.size, cropped: blobs[1].size })
          // C√≥ th·ªÉ retry v·ªõi scale th·∫•p h∆°n n·∫øu c·∫ßn
        }
        
        console.log('‚úÖ Final output:', { 
          mockupSize: mokupImageBlob.size, 
          croppedSize: blobs[1].size,
          canvasSize: `${croppedCanvas.width}x${croppedCanvas.height}`,
          scale: optimalScale,
          isIOS
        })
        
        onSaved(mokupImageBlob, blobs[1], croppedCanvas)
      } catch (error) {
        console.error('‚ùå Capture failed:', error)
        // N·∫øu l√† iOS v√† b·ªã l·ªói, log th√™m th√¥ng tin debug
        if (isIOSDevice()) {
          console.error('üçé iOS device detected. Canvas memory might be exceeded.')
          console.log('üí° Try reducing image sizes or number of images')
        }
        onError(error as Error)
      }
    })
  }

  const saveHtmlAsImageWithDesiredSizeOldVersion = async (
    htmlContainer: HTMLDivElement,
    desiredOutputWidth: number,
    desiredOutputHeight: number,
    desiredImgMimeType: string | null,
    onSaved: (
      imgData: Blob,
      canvasWithDesiredSize: HTMLCanvasElement,
      originalCanvas: HTMLCanvasElement
    ) => void,
    onError: (error: Error) => void
  ) => {
    requestIdleCallback(async () => {
      try {
        const maxImageSizeInPx: number = 5000
        const scale: number = maxImageSizeInPx / htmlContainer.getBoundingClientRect().width
        const canvas = await domToCanvas(htmlContainer, {
          scale: 8,
          quality: 1,
          type: desiredImgMimeType || 'image/webp',
        })
        const finalCanvas = resizeCanvas(canvas, desiredOutputWidth, desiredOutputHeight)
        if (!finalCanvas) {
          throw new Error('Failed to resize canvas to desired size')
        }
        canvas.toBlob((blob) => {
          if (blob) {
            onSaved(blob, finalCanvas, canvas)
          } else {
            onError(new Error('Failed to convert resized canvas to Blob'))
          }
        })
      } catch (error) {
        onError(error as Error)
      }
    })
  }

  const saveHtmlAsImageCropped = async (
    htmlContainer: HTMLDivElement,
    cropBounds: DOMRect,
    desiredOutputWidth: number,
    desiredOutputHeight: number,
    desiredImgMimeType: string | null,
    onSaved: (imgData: Blob, canvasWithDesiredSize: HTMLCanvasElement) => void,
    onError: (error: Error) => void
  ) => {
    try {
      const maxImageSizeInPx: number = 5000
      const scale: number = maxImageSizeInPx / htmlContainer.getBoundingClientRect().width

      // Capture full canvas
      const fullCanvas = await domToCanvas(htmlContainer, {
        scale: scale,
        quality: 1,
        type: desiredImgMimeType || 'image/webp',
      })

      // Crop to print area (scaled coordinates)
      const croppedCanvas = cropCanvas(
        fullCanvas,
        cropBounds.x * scale,
        cropBounds.y * scale,
        cropBounds.width * scale,
        cropBounds.height * scale,
        desiredOutputWidth,
        desiredOutputHeight
      )

      croppedCanvas.toBlob((blob) => {
        if (blob) {
          onSaved(blob, croppedCanvas)
        } else {
          onError(new Error('Failed to convert resized canvas to Blob'))
        }
      }, desiredImgMimeType || 'image/webp')
    } catch (error) {
      onError(error as Error)
    }
  }

  return {
    savePrintAreaAsImage,
    saveHtmlAsImage,
    saveHtmlAsImageWithDesiredSizeOldVersion,
    saveHtmlAsImageCropped,
    saveHtmlAsImageWithDesiredSize,
  }
}
